<dom-module id="grid-row">
    <template>
        <style>
            
            :host {
                display: flex;
                box-sizing: border-box;
                padding: 0;
                margin: 0;
                border: 0;
                position: relative;
            }

            .grid-cell {
                border: 0;
                box-sizing: border-box;
                flex-grow: 1;
                display: block;
                padding: 2px;
                margin: 0 1px 1px 0;
                padding: 4px 3px 3px 3px;
                position: relative;
            }

            .grid-row-header {
                position: relative;
                z-index: 5;
                flex-grow: 0;
                box-shadow: 1px 0px #ccc;
            }
            
            .selection-border {
                position: absolute;
                z-index: 3;
            }

            .selection-border-top {
                top: 0px; left: 0px; width: 100%;
            }

            .selection-border-bottom {
                bottom: 0px; left: 0px; width: 100%;
            }

            .selection-border-left {
                top: 0px; left: 0px; height: 100%;
            }

            .selection-border-right {
                top: 0px; right: 0px; height: 100%;
            }

        </style>

    </template>
    <script>
        Polymer({
            is: "grid-row",

            properties: {
                cells: Array
            },

            create_cell: function( header ){
                let elt = document.createElement( header ? "div" : "pre" );
                elt.className = header ? "grid-cell grid-header" : "grid-cell table-cell fixed-width";
                Polymer.dom( this.root ).appendChild( elt );
                return elt;
            },

            measure2: function( data, header ){

                let m = {
                    row_length: 0,
                    max_height: 0,
                    cell_widths: []
                };

                if( this.mc ) Polymer.dom(this.root).removeChild( this.mc );
                let mc = this.create_cell( header );

                for( let i = 0; i< data.length; i++ ){
                    
                    let w = 0, h = 0;
                    for( let j = 0; j< data[i].length; j++ ){
                        mc.textContent = "M" + data[i][j].toString();
                        w = Math.max( w, mc.offsetWidth );
                        h = Math.max( h, mc.offsetHeight );
                    }

                    m.cell_widths.push( w );
                    m.row_length += w;
                    m.max_height = Math.max( h, m.max_height );

                }

                this.mc = mc;
                return m;

            },

            measure: function( data, header ){
                
                let m = {
                    row_length: 0,
                    max_height: 0,
                    cell_widths: []
                };

                if( this.mc ) Polymer.dom(this.root).removeChild( this.mc );
                let mc = this.create_cell( header );

                for( let i = 0; i< data.length; i++ ){
                    
                    mc.textContent = "M" + data[i].toString();

                    let w = mc.offsetWidth;
                    let h = mc.offsetHeight;

                    m.cell_widths.push( w );
                    m.row_length += w;
                    m.max_height = Math.max( h, m.max_height );

                    m.last_height = h; // allows for proper calculation of the margin

                }

                this.mc = mc;
                return m;

            },

            render: function( selection, column_classes, data, m, row, label, label_width, first_col, last_col, left, header ){

                let index = 0;

                if( !this.row_header ){
                    this.row_header = this.create_cell( true );
                    this.row_header.classList.add( "grid-row-header");
                    this.row_header.style.minWidth = label_width + "px";
                }

                this.row_header.style.left = left + "px";
                this.row_header.textContent = label;
                this.row_header.row = row;
                this.row_header.col = -1;
                this.row_header.style.height = m.max_height + "px";

                if( header ){
                    if( selection.rows && selection.columns )
                        this.row_header.classList.add( "selected" );
                    else this.row_header.classList.remove( "selected" );
                }
                else {
                    if( selection.rows && selection.start.r <= row && selection.end.r >= row )
                        this.row_header.classList.add( "selected" );
                    else this.row_header.classList.remove( "selected" );
                }

                for( let i = first_col; i<= last_col; i++ ){

                    if( this.cells.length <= index ){
                        this.cells[index] = this.create_cell( header );
                    }
                    let cell = this.cells[index];

                    cell.style.minWidth = m.cell_widths[i] + "px";
                    cell.textContent = ( header ? data[i] : data[i][row] ).toString();
                    cell.style.display = "block";
                    cell.row = header ? -1 : row;
                    cell.col = i;
                    cell.style.height = m.max_height + "px";

                    if( header ){
                        if( selection.start.c <= i && selection.end.c >= i && selection.columns ){
                            cell.classList.add( "selected" );
                        }
                        else cell.classList.remove( "selected" );
                    }
                    else {

                        if( column_classes[i] === "date" ) cell.classList.add( "table-cell-date" );
                        else cell.classList.remove( "table-cell-date" );
                        if( column_classes[i] === "string" ) cell.classList.add( "table-cell-string" );
                        else cell.classList.remove( "table-cell-string" );
                        if( column_classes[i] === "factor" ) cell.classList.add( "table-cell-factor" );
                        else cell.classList.remove( "table-cell-factor" );
                    
                        if( selection.start.c <= i 
                            && selection.end.c >= i
                            && selection.start.r <= row 
                            && selection.end.r >= row ){
                                cell.classList.add( "selected" );
                                
                                if( selection.start.r === row ){
                                    let cst = document.createElement( "div" );
                                    cst.className = "selection-border selection-border-top";
                                    cst.style.width = `calc(100% + ${m.horizontal_margin}px)`;
                                    Polymer.dom(cell).appendChild( cst );
                                } 
                                if( selection.end.r === row ){
                                    let cst = document.createElement( "div" );
                                    cst.className = "selection-border selection-border-bottom";
                                    cst.style.width = `calc(100% + ${m.horizontal_margin}px)`;
                                    cst.style.bottom = `-${m.horizontal_margin}px`;
                                    Polymer.dom(cell).appendChild( cst );
                                } 
                                if( selection.start.c === i ){
                                    let cst = document.createElement( "div" );
                                    cst.className = "selection-border selection-border-left";
                                    cst.style.height = `calc(100% + ${m.vertical_margin}px)`;
                                    Polymer.dom(cell).appendChild( cst );
                                } 
                                if( selection.end.c === i ){
                                    let cst = document.createElement( "div" );
                                    cst.className = "selection-border selection-border-right";
                                    cst.style.height = `calc(100% + ${m.vertical_margin}px)`;
                                    cst.style.right = `-${m.vertical_margin}px`;
                                    Polymer.dom(cell).appendChild( cst );
                                } 

                        }
                        else{
                            cell.classList.remove( "selected" );
                            if( cell.select_top ){
                                console.info( "CST2", cell.select_top, cell, Polymer.dom(cell.select_top).parentNode );

                                Polymer.dom(Polymer.dom(cell.select_top).parentNode).removeChild(cell.select_top );
                                cell.select_top = null;
                            }
                        }
                    }
                    index++;
                }
                for( let i = index; i< this.cells.length; i++ ){
                    this.cells[i].style.display = "none";
                }

            },

            created: function(){
                this.cells = [];
            }

        });
    </script>
</dom-module>

<dom-module id="display-grid">
    <template>
        <style>

            :host {
                flex-grow: 1;
                outline: none;
                overflow: hidden;
                position: relative;
                box-sizing: border-box;
                border: 0;
                padding: 0;
                margin: 0;
            }

            #grid-area {
                box-sizing: border-box;
                position: absolute;
                overflow: scroll;
                top: 0px;
                left: 0px;
                right: 0px;
                bottom: 0px;
                border: 0;
                display: flex;
                flex-direction: row;
            }

            #grid-columns {
                display: flex;
                flex-grow: 1;
                box-sizing: border-box;
            }

            #grid-rows {
                position: static;
                box-sizing: border-box;
                margin: 0;
                padding: 0;
                border: 0;
                flex-grow: 1;
            }

            #measurement-node {
                position: absolute;
                top: -210px;
                left: -210px;
                overflow: visible;
                z-index: 2;
            }

            #grid-column-header {
                position: relative;
                top: 0px;
                z-index: 7;
            }

            #grid-row-header-background {
                position: absolute;
                top: 0px;
                left: 0px;
                width: 100px;
                height: 100%;
                z-index: 4;
            }

        </style>

        <div id='grid-area'>
            <div id='grid-columns'>
                <div id='grid-rows'>
                    <div id='grid-row-header-background'></div>
                </div>
            </div>
        </div>

        <div id='measurement-node'></div>

    </template>
    <script>
        Polymer({
            is: "display-grid",

            properties: {
                template: {
                    type: String,
                    value: "grid-row"
                }
            },

            listeners: {
                'mousedown': 'mousedown',
                'keydown': 'keydown'
            },

            clear_selection: function(){
                this.select( -1, -1 );
            },

            patch_selection: function(){
                if( this.selection.rows ) this.selection.end.r = this.row_count;
                if( this.selection.cols ) this.selection.end.c = this.col_count;
            },

            select_range: function( r1, c1, r2, c2, columns, rows ){
                this.selection = {
                    start: { r: r1, c: c1 },
                    end: { r: r2, c: c2 },
                    columns: columns,
                    rows: rows
                }
            },

            select_columns: function( c1, c2 ){
                this.select_range( 0, c1, this.row_count - 1, c2, true, false );
            },

            select_rows: function( r1, r2 ){
                this.select_range( r1, 0, r2, this.col_count - 1, false, true );
            },

            select_all: function(){
                this.select_range( 0, 0, this.row_count-1, this.col_count - 1 );
                this.selection.columns = true;
                this.selection.rows = true;
            },

            select: function( r, c ){
                this.select_range( r, c, r, c );
            },

            copy_selection: function(){

                // this is one place where column-dominant 
                // array is not helpful (didn't we have a fast
                // matrix transpose at one point?)

                if( this.selection.start.r < 0 || this.selection.end.r < 0 ) return;

                let data = [];
                for( let r = this.selection.start.r; r<= this.selection.end.r; r++ ){
                    let line = [];
                    for( let c = this.selection.start.c; c<= this.selection.end.c; c++ ){
                        line.push( this.data[c][r].toString());
                    }
                    data.push( line.join( "\t" ));
                }
                
                const {clipboard} = require('electron');
                clipboard.writeText(data.join("\n"));

            },


            keydown: function(e){

                if( e.keyCode === 27 ){ // escape
                    this.clear_selection();
                    this.refresh();
                }
                else if( e.keyCode === 65 && e.ctrlKey ){
                    this.select_all();
                    this.refresh();
                }
                else if( e.keyCode === 67 && e.ctrlKey ){
                    this.copy_selection();
                }
                else if( e.keyCode == 33 ){ // page up
                    let area = this.$['grid-area'];
                    if( e.shiftKey ){
                        area.scrollLeft = Math.max( 0, area.scrollLeft - area.clientWidth );
                    }
                    else {
                        area.scrollTop = Math.max( 0, area.scrollTop - area.clientHeight );
                    }
                }
                else if( e.keyCode == 34 ){ // page down
                    let area = this.$['grid-area'];
                    if( e.shiftKey ){
                        area.scrollLeft = area.scrollLeft + area.clientWidth;
                    }
                    else {
                        area.scrollTop = area.scrollTop + area.clientHeight;
                    }
                }
                else if( e.keyCode == 37 ){ // left
                    let area = this.$['grid-area'];
                    area.scrollLeft = Math.max( 0, area.scrollLeft - 90 );
                }
                else if( e.keyCode == 38 ){ // up
                    let area = this.$['grid-area'];
                    area.scrollTop = Math.max( 0, area.scrollTop - this.grid_measurements.line_height );
                }
                else if( e.keyCode == 39 ){ // right
                    let area = this.$['grid-area'];
                    area.scrollLeft = area.scrollLeft + 90;
                }
                else if( e.keyCode == 40 ){ // down
                    let area = this.$['grid-area'];
                    area.scrollTop = ( area.scrollTop + this.grid_measurements.line_height );
                }

                else return;

                e.stopPropagation();
                e.preventDefault();

            },

            mousedown: function(e){
                e.stopPropagation();
                e.preventDefault();
                this.focus();

                if( !e.target.className.match( /grid-cell/ )){
                    return;
                }

                let row = e.target.row;
                let col = e.target.col;

                if( row === -1 && col === -1 ){
                    clear_selection();
                    return;
                }
                else if( row === -1 ){
                    this.select_columns( col, col );
                    this.f = this.move_columns;
                }
                else if( col === -1 ){
                    this.select_rows( row, row );
                    this.f = this.move_rows;
                }
                else {
                    this.select( row, col );
                    this.f = this.move_table; 
                }

                this.listen( this, 'mousemove', 'f' );
                this.current_selection = [ row, col ];
                this.selection_start = [ row, col ];
                this.listen( this, 'mouseup', 'mouseup' );
                this.listen( this, 'mouseleave', 'mouseup' );
                
                this.refresh();
            },

            mouseup: function(e){
                e.stopPropagation();
                e.preventDefault();
                this.unlisten( this, 'mousemove', 'f' );
                this.unlisten( this, 'mouseup', 'mouseup' );
                this.unlisten( this, 'mouseleave', 'mouseup' );
            },

            move_columns: function(e){
                e.stopPropagation();
                e.preventDefault();

                if( typeof e.target.row === "undefined" ) return;

                let row = Math.max( 0, e.target.row );
                let col = Math.max( 0, e.target.col );

                if( col === this.current_selection[1] ) return;
                this.select_columns( Math.min( col, this.selection_start[1] ),
                    Math.max( col, this.selection_start[1] ));

                this.current_selection = [ row, col ];
                this.refresh();
            },

            move_rows: function(e){
                e.stopPropagation();
                e.preventDefault();

                if( typeof e.target.row === "undefined" ) return;

                let row = Math.max( 0, e.target.row );
                let col = Math.max( 0, e.target.col );

                if( row === this.current_selection[0] ) return;
                this.select_rows( 
                    Math.min( row, this.selection_start[0] ),
                    Math.max( row, this.selection_start[0] ));

                this.current_selection = [ row, col ];
                this.refresh();

            },

            move_table: function(e){
                e.stopPropagation();
                e.preventDefault();

                if( typeof e.target.row === "undefined" ) return;

                let row = Math.max( 0, e.target.row );
                let col = Math.max( 0, e.target.col );

                if( row === this.current_selection[0] && col === this.current_selection[1] ) return;

                // (maybe) more efficient: flush and recreate
                this.select_range( 
                    Math.min( row, this.selection_start[0] ), 
                    Math.min( col, this.selection_start[1] ), 
                    Math.max( row, this.selection_start[0] ), 
                    Math.max( col, this.selection_start[1] ));

                this.current_selection = [ row, col ];
                this.refresh();

            },

            update: function(opts){

                Object.keys(opts).forEach( function( key ){
                    this[key] = opts[key];
                }, this);
                
                if( this.col_count !== this.data.length ){
                    this.col_count = this.data.length; 
                    this.row_count = this.data[0].length;
                    this.clear_selection();
                    this.measure();
                }

                this.patch_selection();
                this.refresh();
            },

            measure: function(){

                if( !this.measurement ){
                    this.measurement = document.createElement( this.template );
                    Polymer.dom( this.$['measurement-node'] ).appendChild( this.measurement );
                }

                // FIXME: also tallest; for longest, take into account linebreaks

                let newlines = 0;
                let hr1 = process.hrtime();

                let longest = this.data.map( function( col, cindex ){

                    let max = 0;
                    if( col.toString().indexOf("\n") < 0 ){
                        for( let i = 0; i< col.length; i++ ) max = Math.max( max, col[i].toString().length );
                        return "X".repeat(max);
                    }
                    else {
                        for( let i = 0; i< col.length; i++ ){
                            let s = col[i].toString().split("\n" );                        
                            for( let j = 0; j< s.length; j++ ) max = Math.max( max, s[j].length );
                            if( s.length > 1 ) newlines = Math.max( newlines, s.length - 1 );
                        };
                        return "\n".repeat(newlines) + "X".repeat(max);
                    }
                    return tmp[0];
                });

                let hr2 = process.hrtime(hr1);
                console.info("elapsed (2): %ds %dms", hr2[0], hr2[1]/1000000);

                let m = this.measurement.measure( longest );

                m.vertical_margin = this.measurement.offsetHeight - m.last_height;
                m.horizontal_margin = this.measurement.offsetWidth - m.cell_widths[this.col_count-1];

                let tmp = this.row_headers.slice(0);
                tmp.sort( function( a, b ){ return b.toString().length - a.toString().length; });
                let x = this.measurement.measure( [tmp[0]], true );
                this.row_header_width = x.cell_widths[0];

                x = this.measurement.measure( this.column_headers, true );
                x.vertical_margin = this.measurement.offsetHeight - x.last_height;
                x.horizontal_margin = this.measurement.offsetWidth - x.cell_widths[this.column_headers.length-1];

                if( x.max_height > m.max_height ){
                    m.max_height = x.max_height;
                }

                m.row_length = 0;
                for( let i = 0; i< this.col_count; i++ ){
                    m.cell_widths[i] = Math.max( m.cell_widths[i], x.cell_widths[i] );
                    m.row_length += m.cell_widths[i];
                }

                m.line_height = m.max_height + m.vertical_margin;
                m.total_height = ( this.row_count + 1 ) * m.line_height;
                m.total_width = (this.col_count * m.horizontal_margin) + m.row_length;

                this.header_measurements = x;
                this.grid_measurements = m;

                console.info( x, m );

            },

            refresh: function(){
                let instance = this;
                requestAnimationFrame(function(){
                    instance.render();
                });
            },

            attached: function(){
                this.nodes = [];
                if( !this.repaint ) this.repaint = this.refresh.bind(this);
    			this.$['grid-area'].addEventListener('scroll', this.repaint);
                this.tabIndex = 0;
	    	},
		
            detached: function(){
                this.$['grid-area'].removeEventListener('scroll', this.repaint);
            },

            render: function(){

                let m = this.grid_measurements;
                let area = this.$['grid-area'];
                let grid = this.$['grid-rows'];
                let cols = this.$['grid-columns'];

                let rhb = this.$['grid-row-header-background'];

                let buffer = 2;
                let top = area.scrollTop;
                let first_row = Math.max( 0, Math.floor( top / m.line_height ) - buffer );

                // preserve even/odd for styling rules
                if( first_row % 2 === 1 ) first_row--;

                // set margin
                let margin_top = ( m.line_height * first_row );
                grid.style.paddingTop = margin_top + "px";

                let first_col = 0;
                let last_col = this.col_count - 1;

                let padding_left = 0;
                let padding_right = 0;
                let left = area.scrollLeft - 20;
                let right = area.scrollLeft + area.clientWidth + 20;
                let sum = 0;

                for( let i = 0; i< this.col_count-1; i += 2, first_col += 2 ){
                    let w = m.cell_widths[i] + m.cell_widths[i+1] + (2*m.horizontal_margin);
                    if( sum + w >= left ) break;
                    padding_left += w;
                    sum += w;
                }

                for( last_col = first_col; sum < right && last_col< this.col_count; last_col++ ){
                    sum += (m.cell_widths[last_col] + m.horizontal_margin);
                }
                last_col = Math.min( last_col, this.col_count-1 );

                for( let i = last_col + 1; i< this.col_count; i++ ){
                    padding_right += (m.cell_widths[i] + m.horizontal_margin);
                }

                cols.style.paddingLeft = padding_left + "px";
                cols.style.paddingRight = padding_right + "px";
                cols.style.minWidth = m.total_width + "px";

                let height = area.clientHeight + 2 * buffer * m.line_height; 
                let index = 0;

                left = area.scrollLeft - padding_left;

                // render column header
                if( !this.header_row ){
                    this.header_row = document.createElement( this.template );
                    //this.header_row.classList.add( "grid-column-header" );
                    this.header_row.setAttribute("id", "grid-column-header" );
                    this.header_row.style.minHeight = m.max_height + "px";
                    Polymer.dom( grid ).appendChild( this.header_row );
                }
                this.header_row.render( this.selection, [], this.column_headers, m, -1, " ", this.row_header_width, first_col, last_col, left, true );
                this.header_row.style.top = ( area.scrollTop - margin_top ) + "px";

                this.selection.r = undefined;

                // render rows
                while( height > 0 && first_row < this.row_count ){
                    if( index >= this.nodes.length ){
                        this.nodes[index] = document.createElement( this.template );
                        Polymer.dom( grid ).appendChild( this.nodes[index] );
                    }
                    this.nodes[index].render( this.selection, this.column_classes, this.data, m, first_row, this.row_headers[first_row], this.row_header_width, first_col, last_col, left );
                    this.nodes[index].style.display = "flex";

                    index++;
                    first_row++;

                    height -= ( m.max_height + m.vertical_margin );
                }
                for( ; index < this.nodes.length; index++ ){ 
                    this.nodes[index].style.display = "none";
                }

                rhb.style.left = left + "px";
                rhb.style.top = area.scrollTop + "px";
                rhb.style.width = ( this.row_header_width + m.horizontal_margin ) + "px";

                grid.style.height = m.total_height + "px";

            }

        });
    </script>
</dom-module>