<dom-module id="grid-row">
    <template>
        <style>
            
            :host {
                display: flex;
                box-sizing: border-box;
                padding: 0;
                margin: 0;
                border: 0;
                position: relative;
            }

            .grid-cell {
                border: 0;
                box-sizing: border-box;
                flex-grow: 1;
                display: block;
                padding: 2px;
                margin: 0 1px 1px 0;
                text-align: right;
                padding: 6px 2px 0 2px;
            }

            .table-cell {
                background: #fff;
                cursor: cell;
            }

            pre.table-cell {
                line-height: 2;
            }

            .grid-header {
                background: #eee;
                text-align: center;
                cursor: text;
            }

            .grid-row-header {
                position: relative;
                z-index: 4;
                flex-grow: 0;
                box-shadow: 1px 0px #ccc;
            }

            .selected {
                background: lightyellow;
            }

        </style>

    </template>
    <script>
        Polymer({
            is: "grid-row",

            properties: {
                cells: Array
            },

            create_cell: function( header ){
                let elt = document.createElement( header ? "div" : "pre" );
                elt.className = header ? "grid-cell grid-header" : "grid-cell table-cell";
                Polymer.dom( this.root ).appendChild( elt );
                return elt;
            },

            measure: function( data, header ){
                
                let m = {
                    row_length: 0,
                    max_height: 0,
                    cell_widths: []
                };

                if( this.mc ) Polymer.dom(this.root).removeChild( this.mc );
                let mc = this.create_cell( header );

                for( let i = 0; i< data.length; i++ ){
                    
                    mc.textContent = "M" + data[i].toString();

                    let w = mc.offsetWidth;
                    let h = mc.offsetHeight;

                    m.cell_widths.push( w );
                    m.row_length += w;
                    m.max_height = Math.max( h, m.max_height );

                }

                this.mc = mc;
                return m;

            },

            render: function( selection, data, m, row, label, label_width, first_col, last_col, left, header ){

                let index = 0;

                if( !this.row_header ){
                    this.row_header = this.create_cell( true );
                    this.row_header.classList.add( "grid-row-header");
                    this.row_header.style.minWidth = label_width + "px";
                }

                this.row_header.style.left = left + "px";
                this.row_header.textContent = label;
                this.row_header.row = row;
                this.row_header.col = -1;

                for( let i = first_col; i<= last_col; i++ ){

                    if( this.cells.length <= index ){
                        this.cells[index] = this.create_cell( header );
                    }
                    let cell = this.cells[index];

                    cell.style.minWidth = m.cell_widths[i] + "px";
                    cell.textContent = ( header ? data[i] : data[i][row] ).toString();
                    cell.style.display = "block";
                    cell.row = header ? -1 : row;
                    cell.col = i;

                    if( selection.start.c <= i 
                        && selection.end.c >= i
                        && selection.start.r <= row 
                        && selection.end.r >= row ){
                           cell.classList.add( "selected" );
                    }
                    else cell.classList.remove( "selected" );

                    index++;
                }
                for( let i = index; i< this.cells.length; i++ ){
                    this.cells[i].style.display = "none";
                }

            },

            created: function(){
                this.cells = [];
            }

        });
    </script>
</dom-module>

<dom-module id="display-grid">
    <template>
        <style>

            :host {
                flex-grow: 1;
                outline: none;
                overflow: hidden;
                position: relative;
                box-sizing: border-box;
                border: 0;
                padding: 0;
                margin: 0;
                background: #ccc;
            }

            #grid-area {
                box-sizing: border-box;
                position: absolute;
                overflow: scroll;
                top: 0px;
                left: 0px;
                right: 0px;
                bottom: 0px;
                border: 0;
                display: flex;
                flex-direction: row;
            }

            #grid-columns {
                display: flex;
                flex-grow: 1;
                box-sizing: border-box;
            }

            #grid-rows {
                position: static;
                box-sizing: border-box;
                margin: 0;
                padding: 0;
                border: 0;
                flex-grow: 1;
            }

            #measurement-node {
                position: absolute;
                top: -210px;
                left: -210px;
                overflow: visible;
                z-index: 2;
            }

            #selection-area {
                top: 0px;
                left: 0px;
                bottom: 0px;
                right: 0px;
                position: absolute;
                overflow: hidden;
                background: rgba( 0, 0, 0, 0 );
                pointer-events: none;
            }

            #selection-node {
                position: absolute;
                top: -10px;
                left: -10px;
                height: 0px;
                width: 0px;
                box-sizing: border-box;
                background: rgba( 0,0,0,0 );
                border: 3px solid yellow;
                pointer-events: none;
                z-index: 3;

            }

            .grid-column-header {
                position: relative;
                top: 0px;
                z-index: 7;
                background: #ccc;
            }

        </style>

        <div id='grid-area'>
            <div id='grid-columns'>
                <div id='grid-rows'></div>
            </div>
            <div id='selection-area'>
                <div id='selection-node'></div>
            </div>
        </div>

        <div id='measurement-node'></div>

    </template>
    <script>
        Polymer({
            is: "display-grid",

            properties: {
                template: {
                    type: String,
                    value: "grid-row"
                }
            },

            listeners: {
                'mousedown': 'mousedown',
                'keydown': 'keydown'
            },

            clear_selection: function(){
                this.selection = {
                    start: { r: -1, c: -1 },
                    end: { r: -1, c: -1 }
                }
            },

            select_range: function( r1, c1, r2, c2 ){
                this.selection = {
                    start: { r: r1, c: c1 },
                    end: { r: r2, c: c2 }
                }
            },

            select_columns: function( c1, c2 ){
                this.select_range( 0, c1, this.row_count - 1, c2 );
            },

            select_rows: function( r1, r2 ){
                this.select_range( r1, 0, r2, this.col_count - 1 );
            },

            select_all: function(){
                this.select_range( 0, 0, this.row_count-1, this.col_count - 1 );
            },

            select: function( r, c ){
                this.select_range( r, c, r, c );
            },

            copy_selection: function(){

                // this is one place where column-dominant 
                // array is not helpful (didn't we have a fast
                // matrix transpose at one point?)

                if( this.selection.start.r < 0 || this.selection.end.r < 0 ) return;

                let data = [];
                for( let r = this.selection.start.r; r<= this.selection.end.r; r++ ){
                    let line = [];
                    for( let c = this.selection.start.c; c<= this.selection.end.c; c++ ){
                        line.push( this.data[c][r].toString());
                    }
                    data.push( line.join( "\t" ));
                }
                
                const {clipboard} = require('electron');
                clipboard.writeText(data.join("\n"));

            },


            keydown: function(e){

                if( e.keyCode === 27 ){ // escape
                    this.clear_selection();
                    this.refresh();
                }
                else if( e.keyCode === 65 && e.ctrlKey ){
                    this.select_all();
                    this.refresh();
                }
                else if( e.keyCode === 67 && e.ctrlKey ){
                    this.copy_selection();
                }
                else return;

                e.stopPropagation();
                e.preventDefault();

            },

            mousedown: function(e){
                e.stopPropagation();
                e.preventDefault();
                this.focus();

                if( !e.target.className.match( /grid-cell/ )){
                    return;
                }

                let row = e.target.row;
                let col = e.target.col;

                console.info( row, col );

                if( row === -1 && col === -1 ){
                    clear_selection();
                    return;
                }
                else if( row === -1 ){
                    this.select_columns( col, col );
                    this.f = this.move_columns;
                }
                else if( col === -1 ){
                    this.select_rows( row, row );
                    this.f = this.move_rows;
                }
                else {
                    this.select( row, col );
                    this.f = this.move_table; 
                }

                this.listen( this, 'mousemove', 'f' );
                this.current_selection = [ row, col ];
                this.selection_start = [ row, col ];
                this.listen( this, 'mouseup', 'mouseup' );
                this.listen( this, 'mouseleave', 'mouseup' );
                
                this.refresh();
            },

            mouseup: function(e){
                e.stopPropagation();
                e.preventDefault();
                this.unlisten( this, 'mousemove', 'f' );
                this.unlisten( this, 'mouseup', 'mouseup' );
                this.unlisten( this, 'mouseleave', 'mouseup' );
            },

            move_columns: function(e){
                e.stopPropagation();
                e.preventDefault();

                if( typeof e.target.row === "undefined" ) return;

                let row = Math.max( 0, e.target.row );
                let col = Math.max( 0, e.target.col );

                if( col === this.current_selection[1] ) return;
                this.select_columns( Math.min( col, this.selection_start[1] ),
                    Math.max( col, this.selection_start[1] ));

                this.current_selection = [ row, col ];
                this.refresh();
            },

            move_rows: function(e){
                e.stopPropagation();
                e.preventDefault();

                if( typeof e.target.row === "undefined" ) return;

                let row = Math.max( 0, e.target.row );
                let col = Math.max( 0, e.target.col );

                if( row === this.current_selection[0] ) return;
                this.select_rows( 
                    Math.min( row, this.selection_start[0] ),
                    Math.max( row, this.selection_start[0] ));

                this.current_selection = [ row, col ];
                this.refresh();

            },

            move_table: function(e){
                e.stopPropagation();
                e.preventDefault();

                if( typeof e.target.row === "undefined" ) return;

                let row = Math.max( 0, e.target.row );
                let col = Math.max( 0, e.target.col );

                if( row === this.current_selection[0] && col === this.current_selection[1] ) return;

                // (maybe) more efficient: flush and recreate
                this.select_range( 
                    Math.min( row, this.selection_start[0] ), 
                    Math.min( col, this.selection_start[1] ), 
                    Math.max( row, this.selection_start[0] ), 
                    Math.max( col, this.selection_start[1] ), true );

                this.current_selection = [ row, col ];
                this.refresh();

            },

            update: function(opts){

                Object.keys(opts).forEach( function( key ){
                    this[key] = opts[key];
                }, this);
                
                if( this.col_count !== this.data.length ){
                    this.col_count = this.data.length; 
                    this.row_count = this.data[0].length;
                    this.clear_selection();
                    this.measure();
                }
                
                this.refresh();
            },

            measure: function(){

                let longest = this.data.map( function( col ){
                    let tmp = col.slice(0);
                    tmp.sort( function( a, b ){ return b.toString().length - a.toString().length; });
                    return tmp[0];
                });

                if( !this.measurement ){
                    this.measurement = document.createElement( this.template );
                    Polymer.dom( this.$['measurement-node'] ).appendChild( this.measurement );
                }

                let m = this.measurement.measure( longest );

                m.vertical_margin = this.measurement.offsetHeight - m.max_height;
                m.horizontal_margin = this.measurement.offsetWidth - m.cell_widths[this.col_count-1];

                let tmp = this.row_headers.slice(0);
                tmp.sort( function( a, b ){ return b.toString().length - a.toString().length; });
                let x = this.measurement.measure( [tmp[0]], true );
                this.row_header_width = x.cell_widths[0];

                x = this.measurement.measure( this.column_headers, true );
                x.vertical_margin = this.measurement.offsetHeight - x.max_height;
                x.horizontal_margin = this.measurement.offsetWidth - x.cell_widths[this.column_headers.length-1];

                if( x.max_height > m.max_height ){
                    m.max_height = x.max_height;
                }

                m.row_length = 0;
                for( let i = 0; i< this.col_count; i++ ){
                    m.cell_widths[i] = Math.max( m.cell_widths[i], x.cell_widths[i] );
                    m.row_length += m.cell_widths[i];
                }

                m.line_height = m.max_height + m.vertical_margin;
                m.total_height = this.row_count * m.line_height;
                m.total_width = (this.col_count * m.horizontal_margin) + m.row_length;

                this.header_measurements = x;
                this.grid_measurements = m;

            },

            refresh: function(){
                let instance = this;
                requestAnimationFrame(function(){
                    instance.render();
                });
            },

            attached: function(){
                this.nodes = [];
                if( !this.repaint ) this.repaint = this.refresh.bind(this);
    			this.$['grid-area'].addEventListener('scroll', this.repaint);
                this.tabIndex = 0;
	    	},
		
            detached: function(){
                this.$['grid-area'].removeEventListener('scroll', this.repaint);
            },

            render: function(){

                let m = this.grid_measurements;
                let area = this.$['grid-area'];
                let grid = this.$['grid-rows'];
                let cols = this.$['grid-columns'];

                let buffer = 2;
                let top = area.scrollTop;
                let first_row = Math.max( 0, Math.floor( top / m.line_height ) - buffer );

                // preserve even/odd for styling rules
                if( first_row % 2 === 1 ) first_row--;

                // set margin
                let margin_top = ( m.line_height * first_row );
                grid.style.marginTop = margin_top + "px";

                let first_col = 0;
                let last_col = this.col_count - 1;

                let padding_left = 0;
                let padding_right = 0;
                let left = area.scrollLeft - 20;
                let right = area.scrollLeft + area.clientWidth + 20;
                let sum = 0;

                for( let i = 0; i< this.col_count-1; i += 2, first_col += 2 ){
                    let w = m.cell_widths[i] + m.cell_widths[i+1] + (2*m.horizontal_margin);
                    if( sum + w >= left ) break;
                    padding_left += w;
                    sum += w;
                }

                for( last_col = first_col; sum < right && last_col< this.col_count; last_col++ ){
                    sum += (m.cell_widths[last_col] + m.horizontal_margin);
                }
                last_col = Math.min( last_col, this.col_count-1 );

                for( let i = last_col + 1; i< this.col_count; i++ ){
                    padding_right += (m.cell_widths[i] + m.horizontal_margin);
                }

                cols.style.paddingLeft = padding_left + "px";
                cols.style.paddingRight = padding_right + "px";
                cols.style.minWidth = m.total_width + "px";

                let height = area.clientHeight + 2 * buffer * m.line_height; 
                let index = 0;

                left = area.scrollLeft - padding_left;

                // render column header
                if( !this.header_row ){
                    this.header_row = document.createElement( this.template );
                    this.header_row.classList.add( "grid-column-header" );
                    this.header_row.style.minHeight = m.max_height + "px";
                    Polymer.dom( grid ).appendChild( this.header_row );
                }
                this.header_row.render( this.selection, this.column_headers, m, -1, " ", this.row_header_width, first_col, last_col, left, true );
                this.header_row.style.top = ( area.scrollTop - margin_top ) + "px";

                this.selection.r = undefined;

                // render rows
                while( height > 0 && first_row < this.row_count ){
                    if( index >= this.nodes.length ){
                        this.nodes[index] = document.createElement( this.template );
                        Polymer.dom( grid ).appendChild( this.nodes[index] );
                    }
                    this.nodes[index].render( this.selection, this.data, m, first_row, this.row_headers[first_row], this.row_header_width, first_col, last_col, left );
                    this.nodes[index].style.display = "flex";

                    index++;
                    first_row++;

                    height -= ( m.max_height + m.vertical_margin );
                }
                for( ; index < this.nodes.length; index++ ){ 
                    this.nodes[index].style.display = "none";
                }

                let sn = this.$['selection-node'];
                if( this.selection.start.r >= 0 && this.selection.start.c >= 0 ){

                    let sa = this.$['selection-area'];

                    sa.style.left = (this.row_header_width + area.scrollLeft) + "px";
                    sa.style.width = ( area.clientWidth - this.row_header_width ) + "px";
                    sa.style.top = (( m.max_height + m.vertical_margin ) + area.scrollTop) + "px";
                    sa.style.height = ( area.clientHeight - ( m.max_height + m.vertical_margin ) ) + "px";

                    let width = 0;
                    let left = -area.scrollLeft;
                    let top = ( this.selection.start.r ) * ( m.max_height + m.vertical_margin ) - area.scrollTop;

                    for( let i = 0; i<= this.selection.end.c; i++ ){
                        //let w = m.cell_widths[i] + m.horizontal_margin;
                        let w = this.nodes[0].children[i+1].offsetWidth + m.horizontal_margin;
                        if( i >= this.selection.start.c ) width += w;
                        else left += w;
                    }

                    sn.style.left = left + "px";
                    sn.style.top = top + "px";
                    sn.style.height = (( 1 + this.selection.end.r - this.selection.start.r ) * ( m.max_height + m.vertical_margin )) + "px";
                    sn.style.width = width + "px";

                }
                else {
                    sn.style.left = "-20px"
                    sn.style.top = "-20px";
                    sn.style.height = "0px";
                    sn.style.width = "0px";
                }

                let margin_bottom = m.line_height * (this.row_count - first_row);
                grid.style.marginBottom = margin_bottom + "px";

            }

        });
    </script>
</dom-module>